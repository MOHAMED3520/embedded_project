#include "TM4C123.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#define MAX_LENGTH 80
#include <math.h>
#define pi 3.141592654
const float Earth_radius =6371000.0;



void Delay(unsigned long counter);
char UART1_Receiver(void);
void UART5_Transmitter(unsigned char data);
void printstring(char *str);
void extract_lat_lon( char *gprmc_sentence, float *lati, float *longi);
void printFloat_UART5(float number);
void uart_init(void);
float GPS_calc_distance(float current_Lat,float current_Long,float previous_Lat,float previous_Long);
float ToDegree(float val);
float convert_to_Rad(float degree);

int  main(void)
{
		char gprmc_sentence[] = "$GPRMC,123456.789,A,1234.5678,N,5678.1234,E,...";

    float latitude=0.0, longitude=0.0;
	  float current_latitude, current_longitude;
	  float prev_latitude = 3014.190430;
	  float prev_longitude = 3126.626221;
	  float distance=0.0;


    int i = 0;
    char c;	
	  uart_init();
    Delay(1); 
    printstring("Hello World \n");
    Delay(10); 
		

    while(1)
    {
         c = UART1_Receiver(); /* get a character from UART1 */
        if(c == '$') {
            i = 0; /* reset index if we found a new sentence starting */
        }
        *(gprmc_sentence+i) = c;
        i++;
        if(c == '\n') { /* end of sentence */
           gprmc_sentence[i] = '\0'; /* null terminate the string */
            /* check if it's a GPRMC sentence */
					    if (gprmc_sentence[0] == '$' && gprmc_sentence[1] == 'G' && gprmc_sentence[2] == 'P' &&
                  gprmc_sentence[3] == 'R' && gprmc_sentence[4] == 'M' && gprmc_sentence[5] == 'C') {
               printstring(gprmc_sentence);  
                /* Now you can use the latitude and longitude values as needed /              / send the character to UART5 */
               extract_lat_lon( gprmc_sentence, &latitude, &longitude);
							 current_latitude  = latitude;
							 current_longitude = longitude;
               
						 	 printstring("latitude\n");
					   	 printFloat_UART5(latitude);
						   UART5_Transmitter('\n');
						   printstring("longitude\n");
						   printFloat_UART5(longitude);
						   UART5_Transmitter('\n');
							 printstring("prev_latitude\n");
						   printFloat_UART5(prev_latitude);
						   UART5_Transmitter('\n');
							 printstring("prev_longitude\n");
						   printFloat_UART5(prev_longitude);
						   UART5_Transmitter('\n');		
							 distance=GPS_calc_distance(current_latitude,current_longitude,prev_latitude,prev_longitude);
							 printstring("distance\n");
						   printFloat_UART5(distance);
					     UART5_Transmitter('\n');
										
					 
									}else {
        // Invalid GPRMC sentence
        latitude = 0.0f;
        longitude = 0.0f;
    }
						
   }
  }
}
char UART1_Receiver(void)  
{
    char data;
    while((UART1->FR & (1<<4)) != 0); /* wait until Rx buffer is not full */
    data = UART1->DR ;  /* before giving it another byte */
    return (unsigned char) data; 
}


void UART5_Transmitter(unsigned char data)  
{
    while((UART5->FR & (1<<5)) != 0); /* wait until Tx buffer not full */
    UART5->DR = data;                  /* before giving it another byte */
}

void printstring(char *str)
{
    while(*str)
    {
        UART5_Transmitter(*(str++));
    }
}

void Delay(unsigned long counter)
{
    unsigned long i = 0;
    
    for(i=0; i< counter; i++);
}



void printFloat_UART5(float number) {
    char buffer[50];
    char *r = buffer;
    int integerPart, fractionalPart;

    // Handle negative numbers
    if (number < 0) {
        UART5_Transmitter('-'); // Send the minus sign
        number = -number; // Convert to positive for further processing
    }

    // Extract integer and fractional parts
    integerPart = (int)number;
    fractionalPart = (int)((number - integerPart) * 100000); // Assuming 5 decimal places

    // Convert integer part to string
    sprintf(buffer, "%d.", integerPart);
    while (*r != '\0') {
        UART5_Transmitter(*r);
        r++;
    }

    // Convert fractional part to string (ensure 5 digits)
    sprintf(buffer, "%05d", fractionalPart);
    r = buffer;
    while (*r != '\0') {
        UART5_Transmitter(*r);
        r++;
    }
}



void uart_init(void){
    SYSCTL->RCGCUART |= 0x22;  /* enable clock to UART1 and UART5 */
    SYSCTL->RCGCGPIO |= 0x12;  /* enable clock to PORTB for UART1 and PORTE for UART5 */
    Delay(1);
    /* UART1 initialization */
    UART1->CTL = 0;         /* UART1 module disable */
    UART1->IBRD = 104;      /* for 9600 baud rate, integer = 104 */
    UART1->FBRD = 11;       /* for 9600 baud rate, fractional = 11*/
    UART1->CC = 0;          /*select system clock*/
    UART1->LCRH = 0x60;     /* data length 8-bit, not parity bit, no FIFO */
    UART1->CTL = 0x301;     /* Enable UART1 module, Rx and Tx */

    /* UART1 RX1 use PB0. Configure them digital and enable alternate function */
    GPIOB->DEN = 0x01;      /* set PB0 as digital */
    GPIOB->AFSEL = 0x01;    /* Use PB0 alternate function */
    GPIOB->AMSEL = 0;    /* Turn off analog function*/
    GPIOB->PCTL = 0x00000001;     /* configure PB0 for UART */


    /* UART5 initialization */
    UART5->CTL = 0;         /* UART5 module disable */
    UART5->IBRD = 104;      /* for 9600 baud rate, integer = 104 */
    UART5->FBRD = 11;       /* for 9600 baud rate, fractional = 11*/
    UART5->CC = 0;          /*select system clock*/
    UART5->LCRH = 0x60;     /* data length 8-bit, not parity bit, no FIFO */
    UART5->CTL = 0x301;     /* Enable UART5 module, Rx and Tx */

    /* UART5 TX5 use PE5. Configure them digital and enable alternate function */
    GPIOE->DEN = 0x20;      /* set PE5 as digital */
    GPIOE->AFSEL = 0x20;    /* Use PE5 alternate function */
    GPIOE->AMSEL = 0;    /* Turn off analog function*/
    GPIOE->PCTL = 0x00100000;     /* configure PE5 for UART */
	  } 

		
		








//*function to convert GPS values to degree*//
float ToDegree(float val) {
    float result=0;
    int degree = (int)val / 100;
    float minutes = val-(float)degree*100;
    result = degree+ (minutes/60);
    return result;
}
//*function to Convert Degree to Rad*//
float convert_to_Rad(float degree) {
    return degree * (pi / 180.0);
}
//*function to calculate distance between two locations using longitude and latitude in Radians*//
//  Haversine formula: a = sin (?f/2) + cos f1   cos f2   sin (??/2)
//  c = 2 * atan2(sqrt(a), sqrt(1 - a))
// distance = Earth radius *c
float GPS_calc_distance(float current_Lat,float current_Long,float previous_Lat,float previous_Long){
    float prev_lat_rad = convert_to_Rad(ToDegree(previous_Lat));
    float prev_long_rad = convert_to_Rad(ToDegree(previous_Long));
    float current_lat_rad = convert_to_Rad(ToDegree(current_Lat));
    float current_long_rad = convert_to_Rad(ToDegree(current_Long));
    float lat_diff = current_lat_rad - prev_lat_rad;
    float long_diff = current_long_rad - prev_long_rad;

    float a= pow(sin(lat_diff/2),2)+cos(prev_lat_rad)*cos(current_lat_rad)*pow(sin(long_diff/2),2); // Haversine formula: a = sin (?f/2) + cos f1   cos f2   sin (??/2)
    float c = 2 * atan2(sqrt(a), sqrt(1 - a));
    return Earth_radius*c;   //in meters
}

void extract_lat_lon(char *gprmc_sentence, float *latitude, float *longitude) {
    // Check if the sentence starts with "$GPRMC" and has at least 8 parts
    char *comma1 = strchr(gprmc_sentence, ',');
    char *comma2 = strchr(comma1 + 1, ',');
    char *comma3 = strchr(comma2 + 1, ',');
    char *comma4 = strchr(comma3 + 1, ',');
    char *comma5 = strchr(comma4 + 1, ',');
    char *comma6 = strchr(comma5 + 1, ',');
    char lat_dir;
    char lon_dir;

    if (comma1 && comma2 && comma3 && comma4 && comma5 && comma6) {
        // Extract latitude and longitude
        char lat_deg_str[10];
        char lon_deg_str[10];

        // Copy the substrings into null-terminated buffers
        strncpy(lat_deg_str, comma3 + 1, comma4 - comma3 );
        lat_deg_str[comma4 - comma3 - 1] = '\0';  // Null-terminate the string
        strncpy(lon_deg_str, comma5 + 1, comma6 - comma5 );
        lon_deg_str[comma6 - comma5 - 1] = '\0';  // Null-terminate the string

        // Convert to floating-point values
        *latitude = atof(lat_deg_str);
        *longitude = atof(lon_deg_str);

        // Adjust for South or West direction if needed
        if (lat_dir == 'S' || lat_dir == 's') {
            *latitude *= -1;
        }
        if (lon_dir == 'W' || lon_dir == 'w') {
            *longitude *= -1;
        }
    } else {
        // Invalid GPRMC sentence
        *latitude = 0.0f;
        *longitude = 0.0f;
    }
}